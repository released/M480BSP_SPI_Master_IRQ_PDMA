; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;299    
;;;300    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;301    {
;;;302    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;303    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;304    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;305    	
;;;306    }
;;;307    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;203    
;;;204    void PDMA_IRQHandler(void)
000000  4914              LDR      r1,|L3.84|
;;;205    {
;;;206        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000002  6808              LDR      r0,[r1,#0]
;;;207    	
;;;208        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000004  07c2              LSLS     r2,r0,#31
000006  d003              BEQ      |L3.16|
;;;209        {
;;;210    		#if 1
;;;211            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
000008  1d08              ADDS     r0,r1,#4
00000a  6801              LDR      r1,[r0,#0]
00000c  6001              STR      r1,[r0,#0]
                  |L3.14|
;;;212    		#else
;;;213            if (PDMA_GET_ABORT_STS(PDMA) & (1 << SPI_MASTER_TX_DMA_CH))
;;;214            {
;;;215    
;;;216            }
;;;217            PDMA_CLR_ABORT_FLAG(PDMA, (1 << SPI_MASTER_TX_DMA_CH));
;;;218    
;;;219            if (PDMA_GET_ABORT_STS(PDMA) & (1 << SPI_MASTER_RX_DMA_CH))
;;;220            {
;;;221    
;;;222            }
;;;223            PDMA_CLR_ABORT_FLAG(PDMA, (1 << SPI_MASTER_RX_DMA_CH));
;;;224    		#endif
;;;225        }
;;;226        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;227        {
;;;228            if((PDMA_GET_TD_STS(PDMA) & SPI_MASTER_OPENED_CH_TX) == SPI_MASTER_OPENED_CH_TX)
;;;229            {
;;;230                /* Clear PDMA transfer done interrupt flag */
;;;231                PDMA_CLR_TD_FLAG(PDMA, SPI_MASTER_OPENED_CH_TX);
;;;232    
;;;233    			//insert process
;;;234    			SPI_DISABLE_TX_PDMA(SPI1);
;;;235    			LED_Y ^= 1;
;;;236    			
;;;237    			SPI_EnableInt(SPI1, SPI_FIFO_TXTH_INT_MASK);
;;;238            } 		
;;;239        }
;;;240        else if (status & (PDMA_INTSTS_REQTOF0_Msk | PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;241        {
;;;242    		LED_G ^= 1;
;;;243            PDMA_CLR_TMOUT_FLAG(PDMA,SPI_MASTER_TX_DMA_CH);
;;;244        }
;;;245        else
;;;246        {
;;;247    
;;;248        }	
;;;249    }
00000e  4770              BX       lr
                  |L3.16|
000010  0782              LSLS     r2,r0,#30             ;226
000012  d513              BPL      |L3.60|
000014  480f              LDR      r0,|L3.84|
000016  3008              ADDS     r0,r0,#8              ;228
000018  6801              LDR      r1,[r0,#0]            ;228
00001a  07c9              LSLS     r1,r1,#31             ;228
00001c  d0f7              BEQ      |L3.14|
00001e  2101              MOVS     r1,#1                 ;231
000020  6001              STR      r1,[r0,#0]            ;231
000022  480d              LDR      r0,|L3.88|
000024  68c1              LDR      r1,[r0,#0xc]          ;234
000026  f0210101          BIC      r1,r1,#1              ;234
00002a  60c1              STR      r1,[r0,#0xc]          ;234
00002c  490b              LDR      r1,|L3.92|
00002e  680a              LDR      r2,[r1,#0]            ;235
000030  f0820201          EOR      r2,r2,#1              ;235
000034  600a              STR      r2,[r1,#0]            ;235
000036  2180              MOVS     r1,#0x80              ;237
000038  f7ffbffe          B.W      SPI_EnableInt
                  |L3.60|
00003c  f4107f40          TST      r0,#0x300             ;240
000040  d0e5              BEQ      |L3.14|
000042  4806              LDR      r0,|L3.92|
000044  1d00              ADDS     r0,r0,#4              ;242
000046  6802              LDR      r2,[r0,#0]            ;242
000048  f0820201          EOR      r2,r2,#1              ;242
00004c  6002              STR      r2,[r0,#0]            ;242
00004e  1580              ASRS     r0,r0,#22             ;243
000050  6008              STR      r0,[r1,#0]            ;243
000052  4770              BX       lr
;;;250    
                          ENDP

                  |L3.84|
                          DCD      0x4000841c
                  |L3.88|
                          DCD      0x40062000
                  |L3.92|
                          DCD      0x400049c4

                          AREA ||i.SPI1_IRQHandler||, CODE, READONLY, ALIGN=2

                  SPI1_IRQHandler PROC
;;;165    
;;;166    void SPI1_IRQHandler(void)
000000  4809              LDR      r0,|L4.40|
;;;167    {
000002  b510              PUSH     {r4,lr}
;;;168    	// when FIFO empty and BUS not busy
;;;169    	if ((SPI_GET_TX_FIFO_EMPTY_FLAG(SPI1)) && (!SPI_IS_BUSY(SPI1)))
000004  6941              LDR      r1,[r0,#0x14]
000006  03c9              LSLS     r1,r1,#15
000008  d50d              BPL      |L4.38|
00000a  6941              LDR      r1,[r0,#0x14]
00000c  07c9              LSLS     r1,r1,#31
00000e  d10a              BNE      |L4.38|
;;;170        {
;;;171    		set_flag(flag_SPI_Transmit_end,ENABLE);
000010  4906              LDR      r1,|L4.44|
000012  684a              LDR      r2,[r1,#4]  ; BitFlag
000014  f0420204          ORR      r2,r2,#4
000018  604a              STR      r2,[r1,#4]  ; BitFlag
;;;172    		SPI_DisableInt(SPI1, SPI_FIFO_TXTH_INT_MASK);
00001a  2180              MOVS     r1,#0x80
00001c  f7fffffe          BL       SPI_DisableInt
;;;173    		
;;;174    		// CS: de-active
;;;175    		SPI_SET_CS_HIGH;		
000020  4903              LDR      r1,|L4.48|
000022  2001              MOVS     r0,#1
000024  6008              STR      r0,[r1,#0]
                  |L4.38|
;;;176        }
;;;177    }
000026  bd10              POP      {r4,pc}
;;;178    
                          ENDP

                  |L4.40|
                          DCD      0x40062000
                  |L4.44|
                          DCD      ||.data||
                  |L4.48|
                          DCD      0x40004848

                          AREA ||i.SPI_Master_Init||, CODE, READONLY, ALIGN=2

                  SPI_Master_Init PROC
;;;186    */
;;;187    void SPI_Master_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;188    {
;;;189        SPI_Open(SPI1, SPI_MASTER, SPI_MODE_0, 8, SPI_TARGET_FREQ);
000002  4812              LDR      r0,|L5.76|
000004  4d12              LDR      r5,|L5.80|
000006  9000              STR      r0,[sp,#0]
000008  2308              MOVS     r3,#8
00000a  2204              MOVS     r2,#4
00000c  2100              MOVS     r1,#0
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       SPI_Open
;;;190    
;;;191        SYS_UnlockReg();	
000014  f7fffffe          BL       SYS_UnlockReg
;;;192        SYS->GPB_MFPL &= ~( SYS_GPB_MFPL_PB2MFP_Msk);	
000018  046c              LSLS     r4,r5,#17
00001a  6ba0              LDR      r0,[r4,#0x38]
00001c  f4206070          BIC      r0,r0,#0xf00
000020  63a0              STR      r0,[r4,#0x38]
;;;193        SYS->GPB_MFPL |=  SYS_GPB_MFPL_PB2MFP_GPIO;	
000022  6ba0              LDR      r0,[r4,#0x38]
000024  63a0              STR      r0,[r4,#0x38]
;;;194    	GPIO_SetMode(PB,BIT2,GPIO_MODE_OUTPUT);	
000026  2201              MOVS     r2,#1
000028  2104              MOVS     r1,#4
00002a  480a              LDR      r0,|L5.84|
00002c  f7fffffe          BL       GPIO_SetMode
000030  2000              MOVS     r0,#0
000032  f8c40100          STR      r0,[r4,#0x100]
;;;195        SYS_LockReg();	
;;;196    
;;;197    
;;;198        SPI_SetFIFO(SPI1, 3, 3);
000036  2203              MOVS     r2,#3
000038  4611              MOV      r1,r2
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       SPI_SetFIFO
;;;199    //	SPI_EnableInt(SPI1, SPI_FIFO_TXTH_INT_MASK);
;;;200        NVIC_EnableIRQ(SPI1_IRQn);	
000040  e8bd4038          POP      {r3-r5,lr}
000044  2033              MOVS     r0,#0x33
000046  f7ffbffe          B.W      NVIC_EnableIRQ
;;;201    }
;;;202    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x000c3500
                  |L5.80|
                          DCD      0x40062000
                  |L5.84|
                          DCD      0x40004040

                          AREA ||i.SPI_Master_PDMA_Enable||, CODE, READONLY, ALIGN=2

                  SPI_Master_PDMA_Enable PROC
;;;127    
;;;128    void SPI_Master_PDMA_Enable(uint8_t TxRx)
000000  b57c              PUSH     {r2-r6,lr}
;;;129    {
;;;130        uint16_t i = 0;
;;;131        static uint16_t j = 0;
;;;132    	
;;;133        // /CS: active
;;;134    	SPI_SET_CS_LOW;
000002  4922              LDR      r1,|L6.140|
000004  2400              MOVS     r4,#0
000006  600c              STR      r4,[r1,#0]
;;;135    	
;;;136    	set_flag(flag_SPI_Transmit_end,DISABLE);
000008  4a21              LDR      r2,|L6.144|
00000a  6851              LDR      r1,[r2,#4]  ; BitFlag
00000c  f0210104          BIC      r1,r1,#4
000010  6051              STR      r1,[r2,#4]  ; BitFlag
000012  2800              CMP      r0,#0                 ;129
000014  d138              BNE      |L6.136|
;;;137    	
;;;138    	if (TxRx == SPI_TX)
;;;139    	{
;;;140    		//prepare master TX data
;;;141    		g_au8MasterToSlaveTestPattern[0] = 0xAA;
000016  f102010c          ADD      r1,r2,#0xc
00001a  20aa              MOVS     r0,#0xaa
00001c  7008              STRB     r0,[r1,#0]
;;;142    		g_au8MasterToSlaveTestPattern[1] = 0xDD;
00001e  20dd              MOVS     r0,#0xdd
000020  7048              STRB     r0,[r1,#1]
;;;143    
;;;144    	    for (i = 2; i < DATA_NUM ; i++)
000022  2002              MOVS     r0,#2
                  |L6.36|
;;;145    	    {
;;;146    	        g_au8MasterToSlaveTestPattern[i] = i;
000024  5408              STRB     r0,[r1,r0]
000026  1c40              ADDS     r0,r0,#1
000028  b280              UXTH     r0,r0                 ;144
00002a  2808              CMP      r0,#8                 ;144
00002c  d3fa              BCC      |L6.36|
;;;147    	    }
;;;148    		g_au8MasterToSlaveTestPattern[DATA_NUM-1] = (uint8_t) 0x10*j;		//last byte for indicator
00002e  8810              LDRH     r0,[r2,#0]  ; j
;;;149    		j++;
;;;150    		
;;;151    		//TX
;;;152    	    PDMA_SetTransferCnt(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000030  4d18              LDR      r5,|L6.148|
000032  0103              LSLS     r3,r0,#4              ;148
000034  71cb              STRB     r3,[r1,#7]            ;148
000036  1c40              ADDS     r0,r0,#1              ;148
000038  8010              STRH     r0,[r2,#0]            ;149
00003a  2200              MOVS     r2,#0
00003c  2308              MOVS     r3,#8
00003e  4611              MOV      r1,r2
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       PDMA_SetTransferCnt
;;;153    		PDMA_SetTransferAddr(PDMA,SPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&SPI1->TX, PDMA_DAR_FIX);		
000046  f44f6140          MOV      r1,#0xc00
00004a  4813              LDR      r0,|L6.152|
00004c  4a10              LDR      r2,|L6.144|
00004e  e9cd0100          STRD     r0,r1,[sp,#0]
000052  2300              MOVS     r3,#0
000054  320c              ADDS     r2,r2,#0xc
000056  4619              MOV      r1,r3
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       PDMA_SetTransferAddr
;;;154    	    /* Set request source; set basic mode. */
;;;155    	    PDMA_SetTransferMode(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_SPI1_TX, FALSE, 0);
00005e  2300              MOVS     r3,#0
000060  2218              MOVS     r2,#0x18
000062  4619              MOV      r1,r3
000064  4628              MOV      r0,r5
000066  9400              STR      r4,[sp,#0]
000068  f7fffffe          BL       PDMA_SetTransferMode
;;;156    	    SPI_TRIGGER_TX_PDMA(SPI1);	
00006c  490a              LDR      r1,|L6.152|
00006e  3920              SUBS     r1,r1,#0x20
000070  68c8              LDR      r0,[r1,#0xc]
000072  f0400001          ORR      r0,r0,#1
000076  60c8              STR      r0,[r1,#0xc]
;;;157    
;;;158        	PDMA_EnableInt(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_INT_TRANS_DONE);			
000078  b002              ADD      sp,sp,#8
00007a  4628              MOV      r0,r5
00007c  e8bd4070          POP      {r4-r6,lr}
000080  2200              MOVS     r2,#0
000082  4611              MOV      r1,r2
000084  f7ffbffe          B.W      PDMA_EnableInt
                  |L6.136|
;;;159    	}
;;;160    
;;;161    
;;;162    
;;;163    }
000088  bd7c              POP      {r2-r6,pc}
;;;164    
                          ENDP

00008a  0000              DCW      0x0000
                  |L6.140|
                          DCD      0x40004848
                  |L6.144|
                          DCD      ||.data||
                  |L6.148|
                          DCD      0x40008000
                  |L6.152|
                          DCD      0x40062020

                          AREA ||i.SPI_Master_PDMA_PreInit||, CODE, READONLY, ALIGN=2

                  SPI_Master_PDMA_PreInit PROC
;;;90     
;;;91     void SPI_Master_PDMA_PreInit(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;92     {
;;;93         uint16_t i = 0;
;;;94     	
;;;95         // /CS: active
;;;96     	SPI_SET_CS_LOW;
000002  4925              LDR      r1,|L7.152|
000004  2000              MOVS     r0,#0                 ;93
000006  4604              MOV      r4,r0
000008  6008              STR      r0,[r1,#0]
;;;97     
;;;98     	set_flag(flag_SPI_Transmit_end,DISABLE);
00000a  4924              LDR      r1,|L7.156|
00000c  684a              LDR      r2,[r1,#4]  ; BitFlag
00000e  f0220204          BIC      r2,r2,#4
000012  604a              STR      r2,[r1,#4]  ; BitFlag
;;;99     	
;;;100    	//prepare data
;;;101        for (i=0; i < DATA_NUM; i++)
;;;102        {
;;;103            g_au8MasterToSlaveTestPattern[i] = i;
000014  310c              ADDS     r1,r1,#0xc
;;;104            g_au8MasterRxBuffer[i] = 0xFF;
000016  22ff              MOVS     r2,#0xff
000018  f1010308          ADD      r3,r1,#8
                  |L7.28|
00001c  5408              STRB     r0,[r1,r0]            ;103
00001e  541a              STRB     r2,[r3,r0]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0                 ;101
000024  2808              CMP      r0,#8                 ;101
000026  d3f9              BCC      |L7.28|
;;;105        }
;;;106    
;;;107        PDMA_Open(PDMA, SPI_MASTER_OPENED_CH_TX);
000028  4d1d              LDR      r5,|L7.160|
00002a  2101              MOVS     r1,#1
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       PDMA_Open
;;;108    
;;;109    	//TX
;;;110        PDMA_SetTransferCnt(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
000032  2200              MOVS     r2,#0
000034  2308              MOVS     r3,#8
000036  4611              MOV      r1,r2
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       PDMA_SetTransferCnt
;;;111        /* Set source/destination address and attributes */
;;;112        PDMA_SetTransferAddr(PDMA,SPI_MASTER_TX_DMA_CH, (uint32_t)g_au8MasterToSlaveTestPattern, PDMA_SAR_INC, (uint32_t)&SPI1->TX, PDMA_DAR_FIX);
00003e  f44f6140          MOV      r1,#0xc00
000042  4818              LDR      r0,|L7.164|
000044  4a15              LDR      r2,|L7.156|
000046  e9cd0100          STRD     r0,r1,[sp,#0]
00004a  2300              MOVS     r3,#0
00004c  320c              ADDS     r2,r2,#0xc
00004e  4619              MOV      r1,r3
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       PDMA_SetTransferAddr
;;;113        /* Set request source; set basic mode. */
;;;114        PDMA_SetTransferMode(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_SPI1_TX, FALSE, 0);
000056  2300              MOVS     r3,#0
000058  2218              MOVS     r2,#0x18
00005a  4619              MOV      r1,r3
00005c  4628              MOV      r0,r5
00005e  9400              STR      r4,[sp,#0]
000060  f7fffffe          BL       PDMA_SetTransferMode
;;;115        /* Single request type. SPI only support PDMA single request type. */
;;;116        PDMA_SetBurstType(PDMA,SPI_MASTER_TX_DMA_CH, PDMA_REQ_SINGLE, 0);
000064  2300              MOVS     r3,#0
000066  2204              MOVS     r2,#4
000068  4619              MOV      r1,r3
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       PDMA_SetBurstType
;;;117        /* Disable table interrupt */
;;;118        PDMA->DSCT[SPI_MASTER_TX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
000070  6828              LDR      r0,[r5,#0]
000072  f0400080          ORR      r0,r0,#0x80
000076  6028              STR      r0,[r5,#0]
;;;119    
;;;120        SPI_TRIGGER_TX_PDMA(SPI1);
000078  480a              LDR      r0,|L7.164|
00007a  3820              SUBS     r0,r0,#0x20
00007c  68c1              LDR      r1,[r0,#0xc]
00007e  f0410101          ORR      r1,r1,#1
000082  60c1              STR      r1,[r0,#0xc]
;;;121    
;;;122        PDMA_EnableInt(PDMA, SPI_MASTER_TX_DMA_CH, PDMA_INT_TRANS_DONE);
000084  2200              MOVS     r2,#0
000086  4611              MOV      r1,r2
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       PDMA_EnableInt
;;;123    
;;;124        NVIC_EnableIRQ(PDMA_IRQn);
00008e  e8bd407c          POP      {r2-r6,lr}
000092  2028              MOVS     r0,#0x28
000094  f7ffbffe          B.W      NVIC_EnableIRQ
;;;125    
;;;126    }
;;;127    
                          ENDP

                  |L7.152|
                          DCD      0x40004848
                  |L7.156|
                          DCD      ||.data||
                  |L7.160|
                          DCD      0x40008000
                  |L7.164|
                          DCD      0x40062020

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;307    
;;;308    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;309    {
;;;310        /*---------------------------------------------------------------------------------------------------------*/
;;;311        /* Init System Clock                                                                                       */
;;;312        /*---------------------------------------------------------------------------------------------------------*/
;;;313        /* Unlock protected registers */
;;;314        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;315    
;;;316        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;317        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000006  f04f2540          MOV      r5,#0x40004000
00000a  f8d50140          LDR      r0,[r5,#0x140]
00000e  f02000f0          BIC      r0,r0,#0xf0
000012  f8c50140          STR      r0,[r5,#0x140]
;;;318    
;;;319        /* Enable External XTAL (4~24 MHz) */
;;;320        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;321    
;;;322        /* Waiting for 12MHz clock ready */
;;;323        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;324    
;;;325        /* Set core clock as PLL_CLOCK from PLL */
;;;326        CLK_SetCoreClock(FREQ_192MHZ);
000022  481f              LDR      r0,|L8.160|
000024  f7fffffe          BL       CLK_SetCoreClock
;;;327        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;328        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000028  2011              MOVS     r0,#0x11
00002a  0784              LSLS     r4,r0,#30
00002c  f8c40234          STR      r0,[r4,#0x234]
;;;329    
;;;330        /* Enable UART clock */
;;;331        CLK_EnableModuleClock(UART0_MODULE);
000030  4e1c              LDR      r6,|L8.164|
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       CLK_EnableModuleClock
;;;332    
;;;333        /* Select UART clock source from HXT */
;;;334        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
000038  2200              MOVS     r2,#0
00003a  4611              MOV      r1,r2
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       CLK_SetModuleClock
;;;335    
;;;336        CLK_SetModuleClock(SPI1_MODULE, CLK_CLKSEL2_SPI1SEL_PCLK0, MODULE_NoMsk);
000042  4e19              LDR      r6,|L8.168|
000044  2200              MOVS     r2,#0
000046  2180              MOVS     r1,#0x80
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_SetModuleClock
;;;337        CLK_EnableModuleClock(SPI1_MODULE);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       CLK_EnableModuleClock
;;;338    
;;;339        CLK_EnableModuleClock(PDMA_MODULE);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       CLK_EnableModuleClock
;;;340    
;;;341    	TIMER0_HW_Init();
00005a  f7fffffe          BL       TIMER0_HW_Init
;;;342    	TIMER1_HW_Init();
00005e  f7fffffe          BL       TIMER1_HW_Init
;;;343    	
;;;344        /* Update System Core Clock */
;;;345        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;346        SystemCoreClockUpdate();
000062  f7fffffe          BL       SystemCoreClockUpdate
;;;347    
;;;348        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;349        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000066  6be0              LDR      r0,[r4,#0x3c]
000068  f420007f          BIC      r0,r0,#0xff0000
00006c  63e0              STR      r0,[r4,#0x3c]
;;;350        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00006e  6be0              LDR      r0,[r4,#0x3c]
000070  f44000cc          ORR      r0,r0,#0x660000
000074  63e0              STR      r0,[r4,#0x3c]
;;;351    
;;;352        /* Setup SPI1 multi-function pins */
;;;353        SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB4MFP_Msk | SYS_GPB_MFPL_PB5MFP_Msk| SYS_GPB_MFPL_PB3MFP_Msk| SYS_GPB_MFPL_PB2MFP_Msk);	
000076  6ba0              LDR      r0,[r4,#0x38]
000078  490c              LDR      r1,|L8.172|
00007a  4008              ANDS     r0,r0,r1
00007c  63a0              STR      r0,[r4,#0x38]
;;;354        SYS->GPB_MFPL |= SYS_GPB_MFPL_PB4MFP_SPI1_MOSI | SYS_GPB_MFPL_PB5MFP_SPI1_MISO | SYS_GPB_MFPL_PB3MFP_SPI1_CLK | SYS_GPB_MFPL_PB2MFP_SPI1_SS;
00007e  6ba0              LDR      r0,[r4,#0x38]
000080  490b              LDR      r1,|L8.176|
000082  4308              ORRS     r0,r0,r1
000084  63a0              STR      r0,[r4,#0x38]
;;;355    
;;;356        /* Enable SPI1 clock pin (PB3) schmitt trigger */
;;;357        PB->SMTEN |= GPIO_SMTEN_SMTEN3_Msk;
000086  6e68              LDR      r0,[r5,#0x64]
000088  f0400008          ORR      r0,r0,#8
00008c  6668              STR      r0,[r5,#0x64]
;;;358    
;;;359        /* Enable SPI1 I/O high slew rate */
;;;360        GPIO_SetSlewCtl(PB, 0xF, GPIO_SLEWCTL_HIGH);
00008e  2201              MOVS     r2,#1
000090  210f              MOVS     r1,#0xf
000092  4808              LDR      r0,|L8.180|
000094  f7fffffe          BL       GPIO_SetSlewCtl
000098  2000              MOVS     r0,#0
00009a  f8c40100          STR      r0,[r4,#0x100]
;;;361    	
;;;362        /* Lock protected registers */
;;;363        SYS_LockReg();
;;;364    }
00009e  bd70              POP      {r4-r6,pc}
;;;365    
                          ENDP

                  |L8.160|
                          DCD      0x0b71b000
                  |L8.164|
                          DCD      0x57803d10
                  |L8.168|
                          DCD      0x6660000e
                  |L8.172|
                          DCD      0xff0000ff
                  |L8.176|
                          DCD      0x00555500
                  |L8.180|
                          DCD      0x40004040

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2216              MOVS     r2,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  2388              MOVS     r3,#0x88
                  |L9.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;1590
00000e  f8c02100          STR      r2,[r0,#0x100]        ;1591
000012  f8c03100          STR      r3,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L9.10|
;;;1595   }
00001e  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;288    
;;;289    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;290    {
;;;291    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L10.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;292    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;293    }
;;;294    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;294    
;;;295    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;296    {
;;;297    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L11.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;298    }
;;;299    
                          ENDP

                  |L11.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;274    
;;;275    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;276    {
;;;277        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L12.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;278        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;279    }
;;;280    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;280    
;;;281    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;282    {
;;;283        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L13.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;284        TIMER_EnableInt(TIMER1);
;;;285        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;286        TIMER_Start(TIMER1);
;;;287    }
000028  bd10              POP      {r4,pc}
;;;288    
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;250    
;;;251    void TMR1_IRQHandler(void)
000000  4812              LDR      r0,|L14.76|
;;;252    {
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d01c              BEQ      |L14.72|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;253    	static uint16_t CNT = 0;	
;;;254    //	static uint32_t log = 0;	
;;;255    	
;;;256        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;257        {
;;;258            TIMER_ClearIntFlag(TIMER1);
;;;259    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4a0e              LDR      r2,|L14.80|
;;;260    
;;;261    		if ((get_tick() % 50) == 0)
000018  2132              MOVS     r1,#0x32
00001a  6890              LDR      r0,[r2,#8]  ; conter_tick
00001c  fbb0f3f1          UDIV     r3,r0,r1
000020  fb010013          MLS      r0,r1,r3,r0
000024  b918              CBNZ     r0,|L14.46|
;;;262    		{
;;;263    			set_flag(flag_SPI_Transmit_timing , ENABLE);
000026  6850              LDR      r0,[r2,#4]  ; BitFlag
000028  f0400002          ORR      r0,r0,#2
00002c  6050              STR      r0,[r2,#4]  ; BitFlag
                  |L14.46|
;;;264    		}
;;;265    	
;;;266    		if (CNT++ > 1000)
00002e  8850              LDRH     r0,[r2,#2]  ; CNT
000030  1c41              ADDS     r1,r0,#1
000032  8051              STRH     r1,[r2,#2]
000034  f5b07f7a          CMP      r0,#0x3e8
000038  d906              BLS      |L14.72|
;;;267    		{		
;;;268    			CNT = 0;
00003a  2000              MOVS     r0,#0
00003c  8050              STRH     r0,[r2,#2]
;;;269    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;270    			LED_R ^= 1;
00003e  4805              LDR      r0,|L14.84|
000040  6801              LDR      r1,[r0,#0]
000042  f0810101          EOR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
                  |L14.72|
;;;271    		}
;;;272        }
;;;273    }
000048  bd00              POP      {pc}
;;;274    
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      0x40050100
                  |L14.80|
                          DCD      ||.data||
                  |L14.84|
                          DCD      0x400049c0

                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;58     
;;;59     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;60     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;61         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;62         
;;;63         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L15.56|
00000a  f7fffffe          BL       __2printf
;;;64         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L15.42|
                  |L15.16|
;;;65         {
;;;66             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L15.76|
000014  f7fffffe          BL       __2printf
;;;67             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L15.38|
;;;68             {
;;;69                 printf("\r\n");
000020  a00c              ADR      r0,|L15.84|
000022  f7fffffe          BL       __2printf
                  |L15.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;64
                  |L15.42|
00002a  42ac              CMP      r4,r5                 ;64
00002c  dbf0              BLT      |L15.16|
;;;70             }            
;;;71         }
;;;72         printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L15.88|
000034  f7ffbffe          B.W      __2printf
;;;73     }
;;;74     
                          ENDP

                  |L15.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L15.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L15.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L15.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;80     
;;;81     uint32_t get_tick(void)
000000  4801              LDR      r0,|L16.8|
;;;82     {
;;;83     	return (conter_tick);
000002  6880              LDR      r0,[r0,#8]  ; conter_tick
;;;84     }
000004  4770              BX       lr
;;;85     
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;373    
;;;374    int main()
000000  f7fffffe          BL       SYS_Init
;;;375    {
;;;376    	
;;;377        SYS_Init();
;;;378        /* Init UART to 115200-8n1 for print message */
;;;379        UART_Open(UART0, 115200);
000004  f44f31e1          MOV      r1,#0x1c200
000008  481b              LDR      r0,|L17.120|
00000a  f7fffffe          BL       UART_Open
;;;380    
;;;381    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00000e  f7fffffe          BL       CLK_GetCPUFreq
000012  4601              MOV      r1,r0
000014  a019              ADR      r0,|L17.124|
000016  f7fffffe          BL       __2printf
;;;382    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001a  f7fffffe          BL       CLK_GetHXTFreq
00001e  4601              MOV      r1,r0
000020  a01d              ADR      r0,|L17.152|
000022  f7fffffe          BL       __2printf
;;;383    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000026  f7fffffe          BL       CLK_GetLXTFreq
00002a  4601              MOV      r1,r0
00002c  a020              ADR      r0,|L17.176|
00002e  f7fffffe          BL       __2printf
;;;384    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000032  f7fffffe          BL       CLK_GetPCLK0Freq
000036  4601              MOV      r1,r0
000038  a023              ADR      r0,|L17.200|
00003a  f7fffffe          BL       __2printf
;;;385    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00003e  f7fffffe          BL       CLK_GetPCLK1Freq
000042  4601              MOV      r1,r0
000044  a027              ADR      r0,|L17.228|
000046  f7fffffe          BL       __2printf
;;;386    
;;;387    	SPI_Master_Init();
00004a  f7fffffe          BL       SPI_Master_Init
;;;388    	SPI_Master_PDMA_PreInit();
00004e  f7fffffe          BL       SPI_Master_PDMA_PreInit
;;;389    
;;;390    	LED_Init();
000052  f7fffffe          BL       LED_Init
;;;391    	TIMER1_Init();
000056  f7fffffe          BL       TIMER1_Init
;;;392    	
;;;393        /* Got no where to go, just loop forever */
;;;394        while(1)
;;;395        {
;;;396    
;;;397    		if (is_flag_set(flag_SPI_Transmit_timing))	
00005a  4c29              LDR      r4,|L17.256|
                  |L17.92|
00005c  6860              LDR      r0,[r4,#4]  ; BitFlag
00005e  0780              LSLS     r0,r0,#30
000060  d5fc              BPL      |L17.92|
;;;398    		{
;;;399    			set_flag(flag_SPI_Transmit_timing , DISABLE);
000062  6860              LDR      r0,[r4,#4]  ; BitFlag
000064  f0200002          BIC      r0,r0,#2
000068  6060              STR      r0,[r4,#4]  ; BitFlag
;;;400    
;;;401    			if (is_flag_set(flag_SPI_Transmit_end))
00006a  6860              LDR      r0,[r4,#4]  ; BitFlag
00006c  0740              LSLS     r0,r0,#29
00006e  d5f5              BPL      |L17.92|
;;;402    			{
;;;403    				SPI_Master_PDMA_Enable(SPI_TX);				
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       SPI_Master_PDMA_Enable
000076  e7f1              B        |L17.92|
;;;404    			}
;;;405    		}
;;;406        }
;;;407    }
;;;408    
                          ENDP

                  |L17.120|
                          DCD      0x40070000
                  |L17.124|
00007c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000080  4b5f4765
000084  74435055
000088  46726571
00008c  203a2025
000090  38640d0a
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L17.152|
000098  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
00009c  47657448
0000a0  58544672
0000a4  6571203a
0000a8  20253864
0000ac  0d0a00  
0000af  00                DCB      0
                  |L17.176|
0000b0  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000b4  4765744c
0000b8  58544672
0000bc  6571203a
0000c0  20253864
0000c4  0d0a00  
0000c7  00                DCB      0
                  |L17.200|
0000c8  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000cc  47657450
0000d0  434c4b30
0000d4  46726571
0000d8  203a2025
0000dc  38640d0a
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L17.228|
0000e4  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000e8  47657450
0000ec  434c4b31
0000f0  46726571
0000f4  203a2025
0000f8  38640d0a
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L17.256|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;85     
;;;86     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L18.8|
;;;87     {
;;;88     	conter_tick = t;
000002  6088              STR      r0,[r1,#8]  ; conter_tick
;;;89     }
000004  4770              BX       lr
;;;90     
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;75     
;;;76     void tick_counter(void)
000000  4802              LDR      r0,|L19.12|
;;;77     {
;;;78     	conter_tick++;
000002  6881              LDR      r1,[r0,#8]  ; conter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; conter_tick
;;;79     }
000008  4770              BX       lr
;;;80     
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  j
000000  0000              DCW      0x0000
                  ||CNT||
000002  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000
                  conter_tick
                          DCD      0x00000000
                  g_au8MasterToSlaveTestPattern
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_au8MasterRxBuffer
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_468c6c6b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____REVSH|
#line 402
|__asm___6_main_c_468c6c6b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_468c6c6b____RRX|
#line 587
|__asm___6_main_c_468c6c6b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
